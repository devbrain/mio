#[=======================================================================[.rst:
MioAmalgamate
-------------

CMake module for generating single-header amalgamation of mio library.

Functions
^^^^^^^^^

.. command:: mio_create_single_header

  Creates a single-header amalgamation from multiple source files::

    mio_create_single_header(
        OUTPUT <output_file>
        SOURCES <source1> [<source2> ...]
        INCLUDE_PATHS <path1> [<path2> ...]
    )

  Creates a custom target ``mio_amalgamate`` that generates the single-header
  file at configure time and adds a build target to regenerate it.

#]=======================================================================]

function(mio_create_single_header)
    cmake_parse_arguments(ARG "" "OUTPUT" "SOURCES;INCLUDE_PATHS" ${ARGN})

    if(NOT ARG_OUTPUT)
        message(FATAL_ERROR "mio_create_single_header: OUTPUT is required")
    endif()

    if(NOT ARG_SOURCES)
        message(FATAL_ERROR "mio_create_single_header: SOURCES is required")
    endif()

    if(NOT ARG_INCLUDE_PATHS)
        message(FATAL_ERROR "mio_create_single_header: INCLUDE_PATHS is required")
    endif()

    # Create the amalgamation script
    set(AMALGAMATE_SCRIPT "${CMAKE_CURRENT_BINARY_DIR}/mio_amalgamate.cmake")

    # Convert lists to space-separated for the script
    string(REPLACE ";" "|" SOURCES_PIPE "${ARG_SOURCES}")
    string(REPLACE ";" "|" INCLUDE_PATHS_PIPE "${ARG_INCLUDE_PATHS}")

    file(WRITE "${AMALGAMATE_SCRIPT}" "
# MIO Single-Header Amalgamation Script
# Generated by MioAmalgamate.cmake

cmake_minimum_required(VERSION 3.14)

set(OUTPUT_FILE \"${ARG_OUTPUT}\")
set(SOURCE_FILES_STR \"${SOURCES_PIPE}\")
set(INCLUDE_PATHS_STR \"${INCLUDE_PATHS_PIPE}\")

# Convert pipe-separated back to lists
string(REPLACE \"|\" \";\" SOURCE_FILES \"\${SOURCE_FILES_STR}\")
string(REPLACE \"|\" \";\" INCLUDE_PATHS \"\${INCLUDE_PATHS_STR}\")

# Track which files have been included
set(INCLUDED_FILES \"\" CACHE INTERNAL \"\")

# Read a file and process its includes recursively
function(process_file FILE_PATH RESULT_VAR IS_ROOT)
    # Normalize path
    get_filename_component(FILE_PATH \"\${FILE_PATH}\" ABSOLUTE)

    # Check if already included
    list(FIND INCLUDED_FILES \"\${FILE_PATH}\" ALREADY_INCLUDED)
    if(NOT ALREADY_INCLUDED EQUAL -1)
        set(\${RESULT_VAR} \"\" PARENT_SCOPE)
        return()
    endif()

    # Mark as included
    set(INCLUDED_FILES \"\${INCLUDED_FILES};\${FILE_PATH}\" CACHE INTERNAL \"\")

    # Read the file
    if(NOT EXISTS \"\${FILE_PATH}\")
        message(FATAL_ERROR \"File not found: \${FILE_PATH}\")
    endif()
    file(READ \"\${FILE_PATH}\" CONTENT)

    # Get directory of current file for relative includes
    get_filename_component(FILE_DIR \"\${FILE_PATH}\" DIRECTORY)

    # Normalize line endings
    string(REGEX REPLACE \"\\r\\n\" \"\\n\" CONTENT \"\${CONTENT}\")

    # Remove #pragma once from non-root files
    if(NOT IS_ROOT)
        string(REGEX REPLACE \"#[ \\t]*pragma[ \\t]+once[^\\n]*\\n?\" \"\" CONTENT \"\${CONTENT}\")
    endif()

    # Process includes line by line
    set(OUTPUT_CONTENT \"\")
    string(LENGTH \"\${CONTENT}\" CONTENT_LEN)

    # Use regex to find and replace includes
    set(REMAINING \"\${CONTENT}\")
    while(TRUE)
        # Find next #include directive
        string(REGEX MATCH \"#[ \\t]*include[ \\t]+[<\\\"]([^>\\\"]+)[>\\\"]\" MATCH \"\${REMAINING}\")
        if(NOT MATCH)
            string(APPEND OUTPUT_CONTENT \"\${REMAINING}\")
            break()
        endif()

        # Get position of match
        string(FIND \"\${REMAINING}\" \"\${MATCH}\" MATCH_POS)

        # Add content before the match
        if(MATCH_POS GREATER 0)
            string(SUBSTRING \"\${REMAINING}\" 0 \${MATCH_POS} BEFORE_MATCH)
            string(APPEND OUTPUT_CONTENT \"\${BEFORE_MATCH}\")
        endif()

        # Extract include path
        string(REGEX REPLACE \"#[ \\t]*include[ \\t]+[<\\\"]([^>\\\"]+)[>\\\"]\"\n               \"\\\\1\" INCLUDE_PATH \"\${MATCH}\")

        # Determine if it's a quoted include
        string(FIND \"\${MATCH}\" \"\\\"\" QUOTE_POS)

        # Try to find the included file
        set(FOUND_PATH \"\")

        # For quoted includes, first try relative to current file
        if(NOT QUOTE_POS EQUAL -1)
            if(EXISTS \"\${FILE_DIR}/\${INCLUDE_PATH}\")
                get_filename_component(FOUND_PATH \"\${FILE_DIR}/\${INCLUDE_PATH}\" ABSOLUTE)
            endif()
        endif()

        # Try include paths
        if(NOT FOUND_PATH)
            foreach(INC_PATH IN LISTS INCLUDE_PATHS)
                if(EXISTS \"\${INC_PATH}/\${INCLUDE_PATH}\")
                    get_filename_component(FOUND_PATH \"\${INC_PATH}/\${INCLUDE_PATH}\" ABSOLUTE)
                    break()
                endif()
            endforeach()
        endif()

        # If found in our paths, inline it
        if(FOUND_PATH)
            string(APPEND OUTPUT_CONTENT \"// \${MATCH}\\n\")
            process_file(\"\${FOUND_PATH}\" NESTED_CONTENT FALSE)
            string(APPEND OUTPUT_CONTENT \"\${NESTED_CONTENT}\")
        else()
            # Keep external includes as-is
            string(APPEND OUTPUT_CONTENT \"\${MATCH}\")
        endif()

        # Move past the match
        string(LENGTH \"\${MATCH}\" MATCH_LEN)
        math(EXPR AFTER_POS \"\${MATCH_POS} + \${MATCH_LEN}\")
        string(SUBSTRING \"\${REMAINING}\" \${AFTER_POS} -1 REMAINING)
    endwhile()

    set(\${RESULT_VAR} \"\${OUTPUT_CONTENT}\" PARENT_SCOPE)
endfunction()

# Reset included files tracker
set(INCLUDED_FILES \"\" CACHE INTERNAL \"\")

# Process each source file
set(AMALGAMATION \"\")
foreach(SOURCE IN LISTS SOURCE_FILES)
    message(STATUS \"Processing: \${SOURCE}\")
    process_file(\"\${SOURCE}\" FILE_CONTENT TRUE)
    string(APPEND AMALGAMATION \"\${FILE_CONTENT}\")
endforeach()

# Ensure output directory exists
get_filename_component(OUTPUT_DIR \"\${OUTPUT_FILE}\" DIRECTORY)
file(MAKE_DIRECTORY \"\${OUTPUT_DIR}\")

# Write the amalgamation
file(WRITE \"\${OUTPUT_FILE}\" \"\${AMALGAMATION}\")
message(STATUS \"Generated: \${OUTPUT_FILE}\")
")

    # Run at configure time
    message(STATUS "Generating single-header amalgamation...")
    execute_process(
        COMMAND ${CMAKE_COMMAND} -P "${AMALGAMATE_SCRIPT}"
        RESULT_VARIABLE RESULT
        OUTPUT_VARIABLE OUTPUT
        ERROR_VARIABLE ERROR)

    if(NOT RESULT EQUAL 0)
        message(WARNING "Failed to generate amalgamation: ${ERROR}")
    else()
        message(STATUS "${OUTPUT}")
    endif()

    # Create a target for regeneration
    add_custom_target(mio_amalgamate
        COMMAND ${CMAKE_COMMAND} -P "${AMALGAMATE_SCRIPT}"
        SOURCES ${ARG_SOURCES}
        COMMENT "Regenerating mio single-header amalgamation"
        VERBATIM)

endfunction()
